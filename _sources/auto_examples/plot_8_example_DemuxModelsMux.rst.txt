

.. _sphx_glr_auto_examples_plot_8_example_DemuxModelsMux.py:


.. _example8:

Eighth Example: # Dynamically built component using input signal values during the fit stage
--------------------------------------------------------------------------------------------

We continue demonstrating several interesting features:
 1. How the user can choose to encapsulate several blocks into a PipeGraph and use it as a single unit in another PipeGraph
 2. How these components can be dynamically built on runtime depending on initialization parameters
 3. How these components can be dynamically built on runtime depending on input signal values during fit
 4. Using GridSearchCV to explore the best combination of hyperparameters




.. code-block:: python

    import numpy as np
    import pandas as pd
    import matplotlib.pyplot as plt
    from sklearn.preprocessing import MinMaxScaler
    from sklearn.mixture import GaussianMixture

    from sklearn.linear_model import LinearRegression
    from pipegraph.base import PipeGraphRegressor, RegressorsWithDataDependentNumberOfReplicas

    X_first = pd.Series(np.random.rand(100,))
    y_first = pd.Series(4 * X_first + 0.5*np.random.randn(100,))
    X_second = pd.Series(np.random.rand(100,) + 3)
    y_second = pd.Series(-4 * X_second + 0.5*np.random.randn(100,))
    X_third = pd.Series(np.random.rand(100,) + 6)
    y_third = pd.Series(2 * X_third + 0.5*np.random.randn(100,))

    X = pd.concat([X_first, X_second, X_third], axis=0).to_frame()
    y = pd.concat([y_first, y_second, y_third], axis=0).to_frame()







Now we consider the possibility of using the classifier's output to automatically adjust the number of replicas.
This can be seen as PipeGraph changing its inner topology to adapt its connections and steps to other components
context. This morphing capability opens interesting possibilities to explore indeed.



.. code-block:: python


    import inspect
    print(inspect.getsource(RegressorsWithDataDependentNumberOfReplicas))





.. rst-class:: sphx-glr-script-out

 Out::

    class RegressorsWithDataDependentNumberOfReplicas(PipeGraph, RegressorMixin):
        def __init__(self, model_prototype=LinearRegression(), model_parameters={}):
            self.model_prototype = model_prototype
            self.model_parameters = model_parameters
            self._fit_data = {}
            self._predict_data = {}
            self.steps = []

        def fit(self, *pargs, **kwargs):
            number_of_replicas = len(set(kwargs['selection']))
            self.steps = [('models', RegressorsWithParametrizedNumberOfReplicas(number_of_replicas=number_of_replicas,
                                                                                model_parameters=self.model_parameters))]

            self._processes = {name: wrap_adaptee_in_process(adaptee=step_model) for name, step_model in self.steps}

            self.fit_connections = dict(models={'X': 'X',
                                                'y': 'y',
                                                'selection': 'selection'})
            self.predict_connections = self.fit_connections
            self._fit_graph = build_graph(self.fit_connections)
            self._predict_graph = build_graph(self.predict_connections)
            super().fit(*pargs, **kwargs)
            return self


Using this new component we can build a simplified PipeGraph:



.. code-block:: python


    scaler = MinMaxScaler()
    gaussian_mixture = GaussianMixture(n_components=3)
    models = RegressorsWithDataDependentNumberOfReplicas(model_prototype=LinearRegression(), model_parameters={})

    steps = [('scaler', scaler),
             ('classifier', gaussian_mixture),
             ('models', models), ]

    connections = {'scaler': {'X': 'X'},
                   'classifier': {'X': 'scaler'},
                   'models': {'X': 'scaler',
                              'y': 'y',
                              'selection': 'classifier'},
                   }

    pgraph = PipeGraphRegressor(steps=steps, fit_connections=connections)
    pgraph.fit(X, y)
    y_pred = pgraph.predict(X)
    plt.scatter(X, y)
    plt.scatter(X, y_pred)



.. image:: /auto_examples/images/sphx_glr_plot_8_example_DemuxModelsMux_001.png
    :align: center




**Total running time of the script:** ( 0 minutes  0.069 seconds)



.. only :: html

 .. container:: sphx-glr-footer


  .. container:: sphx-glr-download

     :download:`Download Python source code: plot_8_example_DemuxModelsMux.py <plot_8_example_DemuxModelsMux.py>`



  .. container:: sphx-glr-download

     :download:`Download Jupyter notebook: plot_8_example_DemuxModelsMux.ipynb <plot_8_example_DemuxModelsMux.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.readthedocs.io>`_
